package frc.robot.tank;

import edu.wpi.first.math.controller.RamseteController;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
//import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.math.util.Units;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
//import edu.wpi.first.wpilibj.AnalogGyro;
//import edu.wpi.first.wpilibj.AnalogInput;
//import edu.wpi.first.wpilibj.CounterBase.EncodingType;
//import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
//import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.motorcontrol.PWMVictorSPX;



public class tanks {

    private PWMVictorSPX left1;
    private PWMVictorSPX left2;
    private MotorControllerGroup leftMotor;
    private PWMVictorSPX right1;
    private PWMVictorSPX right2;
    private MotorControllerGroup rightMotor;
    private DifferentialDrive drive;
    private DifferentialDrive m_robotDrive;
    private Joystick m_leftStick;
    private Joystick m_rightStick;
    //private Encoder leftencoder;
    //private Encoder rightencoder;
    //private AnalogGyro gyro;    

    public tanks(){
        m_robotDrive = new DifferentialDrive(leftMotor, rightMotor);
        drive = new DifferentialDrive(leftMotor, rightMotor);
        m_leftStick = new Joystick(0);
        m_rightStick = new Joystick(1);
    }
    
    
    public void init(){
        left1 = new PWMVictorSPX(0);
        //addChild("left1",left1);
        left1.setInverted(false);

        left2 = new PWMVictorSPX(1);
        //addChild("left2",left2);
        left2.setInverted(false);

        leftMotor = new MotorControllerGroup(left1, left2);
        //addChild("leftMotor", leftMotor);

        right1 = new PWMVictorSPX(2);
        //addChild("right1",right1);
        right1.setInverted(false);

        right2 = new PWMVictorSPX(3);
        //addChild("right2",right2);
        right2.setInverted(false);


        rightMotor = new MotorControllerGroup(right1, right2);
        //addChild("rightMotor", rightMotor);

        drive.setMaxOutput(1.0);
        drive.setSafetyEnabled(true);
    }

 
    public void setSpeed(double vx, double angularVel){

        DifferentialDriveKinematics kinematics =
        //takes trackwidth as a parameter
        new DifferentialDriveKinematics(Units.inchesToMeters(27.0));

        var speed = new ChassisSpeeds(vx, 0.0, angularVel);
        
        DifferentialDriveWheelSpeeds wheelSpeeds = kinematics.toWheelSpeeds(speed);

        double leftVelocity = wheelSpeeds.leftMetersPerSecond;

        double rightVelocity = wheelSpeeds.rightMetersPerSecond;

        leftMotor.set(leftVelocity);
        rightMotor.set(rightVelocity);

    }

    //make a move to point method for auto 
    public void setVoltage(double rightVolts, double leftVolts){
        leftMotor.setVoltage(leftVolts);
        rightMotor.setVoltage(rightVolts);
    }

    public void teleopPeriodic(){
        m_robotDrive.tankDrive(-m_leftStick.getY(), -m_rightStick.getY());
    }

    public void simulationPeriodic(){
        
    }

    public void drive(double left, double right){
        drive.tankDrive(left, right);
    }

    //default 2 and 0.7
    /**
     * 
     * @param b - Tuning parameter (b > 0 rad²/m²) for which larger values make convergence more aggressive like a proportional term.
     * @param zeta Tuning parameter (0 rad⁻¹ < zeta < 1 rad⁻¹) for which larger values provide more damping in response.
     */
    public void curveFollower(double b, double zeta, Pose2d desiredPose){
        ChassisSpeeds speed = new ChassisSpeeds();
        RamseteController rc = new RamseteController();
        speed.calculate(Pigeon2.currentPose(),;
    }
}
